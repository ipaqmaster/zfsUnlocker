#!/bin/bash

sealedError='{"errors":["Vault is sealed"]}'
badTokenError='{"errors":["permission denied"]}'
validTokenPermissionDeniedError='{"errors":["1 error occurred:\n\t* permission denied\n\n"]}'
blankResponseError='{"errors":[]}'
curlErrorRegex='^curl:.*$'

function kernelArgumentSpiel {
  echo -e "\t\tKernel arguments: VAULTHOSTOVERRIDE=xxx and VAULTTOKENOVERRIDE=xxx"
  echo -e "\t\tCan be used to override vault vars without initramfs regeneration."
}

function curlErrorHandler {
  goalText="${1}"
  successText="${2}"

  if [ ${curlReturnCode} -eq 0 ] && jq -e .request_id <<< ${response} 2>&1 >/dev/null
  then
    echo -e "${successText}"
    return ${curlReturnCode}
  elif [ "${response}" == "${blankResponseError}" ]
  then
    echo -e "\t\tVault returned a blank response for ${lockedDataset}."
    echo -e "\t\tYou have access to read this secret path but it may not exist."
    return 1
  elif [ "${response}" == "${validTokenPermissionDeniedError}" ]
  then
    echo -e "\t\tVault claims our token doesn't have permission to read the secret for ${lockedDataset}."
    echo -e "\t\tPlease consult your policies."
    return 1
  elif [ "${response}" == "${sealedError}" ]
  then
    echo -e "\t\tThe vault address provided claims to be sealed."
    echo -e "\t\tCannot continue until its unsealed."
    return 1
  elif [ "${response}" == "${badTokenError}" ]
  then
    echo -e "\t\tVault server reachable but trying to lookup own token resulted in a permission error."
    echo -e "\t\tToken may be invalid. If valid, policies may be too tight."
    kernelArgumentSpiel
    return 1
  elif [[ "$(head -n1 <<< ${response})" =~ ${curlErrorRegex} ]] # If we're dealing with a cURL error
  then
    echo -e "\t\tcURL threw an error trying to ${goalText} against ${vaultHost}"
    echo
    sed -E -e 's/^/\t\t\t/g' <<< "${response}" # Share cURL's output
  else # If we don't know what we're looking at
    echo -e "\t\tSomething else went wrong trying to ${goalText} against ${vaultHost} [cURL exit code ${curlReturnCode}]"
  fi

}

function curler {
  # Try to work around sealed or unreachable cluster members.
  # '--retry' and Co don't establish new connections - preventing RRDNS from rerolling.

  [ -n "${MODE}" ] && METHOD="-X ${MODE}"

  retryAttempts=10 attemptNumber=0

  while [[ ${attemptNumber} -lt ${retryAttempts} ]]
  do
    (((attemptNumber++)))
    #echo ${attemptNumber} >&2
    #echo "curl -q -sS ${METHOD} -H \"X-Vault-Token: ${vaultToken}\" \"${URL}\" 2>&1"
    response="$(curl -q -sS ${METHOD} -H "X-Vault-Token: ${vaultToken}" "${URL}" 2>&1)" ; curlReturnCode=$?
    if [ "${response}" == "${sealedError}" ]
    then
      [ ${attemptNumber} -eq 1 ] && echo -e "\t\tHit sealed vault... retrying" >&2
    else
      break
    fi
  done

  curlErrorHandler "${1}" "${2}" # Check for problems before continuing
  return ${?}
}

function checkVaultTokenValid {
    # Do a self-lookup API call before waiting any time
  URL="${baseURL}/auth/token/lookup-self"
  MODE=GET
  curler "validate the token" "\t\tAccessing vault [${vaultHost}] successful, Token is valid"
  return ${?}
}

function attemptVaultRead {
  URL="${baseURL}/${vaultKvEngineName}/${vaultRootSearchPath}/${lockedDataset}"
  curler "Read the kv secret" "\t\t\tSuccessfully read secret data"
  return ${?}
}

function hook {

  if [ -f /etc/zfsUnlocker/zfsUnlocker.conf ]
  then
    . /etc/zfsUnlocker/zfsUnlocker.conf
  else
    echo "\t\t/etc/zfsUnlocker/zfsUnlocker.conf missing, skipping module."
    return 1
  fi

    # Check for kernel argument overrides and use them if available.
  if [ -n "${VAULTHOSTOVERRIDE}" ] || [ -n "${VAULTTOKENOVERRIDE}" ]
  then
    echo -e "\t\tCustom vault args provided in kernel arguments, using those..."
    [ -n "${VAULTHOSTOVERRIDE}" ]  && vaultHost=${VAULTHOSTOVERRIDE}   && echo -e "\t\tSet vault host from cmdline"
    [ -n "${VAULTTOKENOVERRIDE}" ] && vaultToken=${VAULTTOKENOVERRIDE} && echo -e "\t\tSet vault token from cmdline"
    chmod 440 /proc/cmdline # Best effort protection from regular processes
    echo -e "\t\t/proc/cmdline permissions switched to 440 to help protect token."
  fi

  if [ ${vaultPromptForMissingInfo} -eq 1 ] && [ -z "${vaultToken}" -o -z "${vaultHost}" ]
  then
    echo -e "\t\tPrompting enabled and I have no keys, prompting for extra details..."
    [ -z "${vaultToken}" ] && read -sp "Vault Token:" vaultToken
    [ -z "${vaultHost}" ]  && read -sp "Vault Host:" vaultHost
  fi

  if [ -z "${vaultToken}" ] || [ -z "${vaultHost}"  ]
  then
    echo -e "\t\tNot enough info to run vault hook"
    [ -z "${vaultHost}" ]  && echo -e "\t\tVault host missing"
    [ -z "${vaultToken}" ] && echo -e "\t\tVault token missing"
    kernelArgumentSpiel
    return 1
  fi

  baseURL="https://${vaultHost}/v1"

  checkVaultTokenValid || exit 1

    # Try unlocking all datasets with an 'unavailable' keystatus, but root first.

  if [ -n "${testDataset}" ]
  then 
    lockedDatasets="${testDataset}"
  else
    lockedDatasets="${dataset} $(zfs get -H -o name,value keystatus 2>/dev/null | grep unavailable | grep -v '@' | cut -f1)"
  fi

  for lockedDataset in ${lockedDatasets}
  do

      # If unlocked and not a test run, skip
    grep -qsP '\tavailable' <<< $(zfs get -H -o name,value keystatus ${lockedDataset} 2>/dev/null) && [ -z "${testDataset}" ] && continue

    echo -e "\n\t\tUnlocking ${lockedDataset}"
    [ -n "${testDataset}" ] && echo -e "\t\tAttempting unlock of: ${lockedDataset}"

    attemptVaultRead || exit 1
    vaultPassphraseResult="$(jq -e -r '.data.data.passphrase' <<< ${response})" ; jqParseExitCode=$?
    [ ${jqParseExitCode} -gt 0 ] && { echo -e "\t\tFailed to read a passphrase from the result" ; exit 1 ;}

    [ -n "${testDataset}" ] && echo -e "\t\tPassphrase of $(wc -m <<<"${vaultPassphraseResult}") length found for ${testDataset}"

    if result=$(yes "${vaultPassphraseResult}" | zfs load-key ${lockedDataset} 2>&1)
    then
        echo -e "\t\t\tSuccessfully unlocked ${lockedDataset}"
    else
        sed 's/^/\t\t\t/g' <<<${result}
        fi

      # Quietly try the passphrase on other datasets too
    yes "${vaultPassphraseResult}" | zfs load-key -a >/dev/null 2>&1
  done
}


function test { # For someone to test the hook with before rebooting
  echo "This is a test function to try reading a vault dataset secret before rebooting."

}

function cleanup {
 : 
}

if [ "${1}" == 'test' ]
then
  echo "Entering test mode."
  echo "Reading existing /proc/cmdline arguments..."
  for keyValue in $(</proc/cmdline) ; do eval $keyValue 2>/dev/null ; done

  if [ "${2}" ]
  then
    testDataset=${2} hook
  else
    echo "Please provide a dataset name as an argument."
  fi
else
  ${1}
fi
